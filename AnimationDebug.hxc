import flixel.FlxG;
import flixel.FlxSprite;
import flixel.util.FlxStringUtil;
import flixel.math.FlxPoint;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import flixel.math.FlxMath;
import funkin.Conductor;
import funkin.Paths;
import funkin.play.PlayState;
import funkin.modding.module.Module;
import funkin.play.character.BaseCharacter;
import funkin.graphics.FunkinSprite;
import funkin.modding.PolymodHandler;
import funkin.util.FileUtil;
import funkin.audio.FunkinSound;

class AnimationDebugModule extends Module
{
    function new(){
        super("AnimationDebug", 1, {state: PlayState});
    }

    var shit:FlxText;
    var piss:FlxText;
    var animSelected:Int = 0;
    var charSelected:Int = 0;
    var freeze:Bool = false; 
    var allowed:Bool = false;
    var loaded:Bool = false;

    var bf:BaseCharacter;
    var dad:BaseCharacter;
    var gf:BaseCharacter;

    var bfList:Array<String> = [];
    var dadList:Array<String> = [];
    var gfList:Array<String> = [];

    var characters:Array<BaseCharacter> = [];
    var curCharList;
    var animDefs:Array<String> = ["singLEFT","singDOWN","singUP","singRIGHT"];

    var onionBf:FunkinSprite;
    var onionDad:FunkinSprite;
    var onionGf:FunkinSprite;

    var onionArray:Array<String> = [];

    var dialogueWow:Array<String> = [
        "LEFT / RIGHT for selecting the animation, UP / DOWN for selecting the character.",
        "Z / SPACE for playing animation, X / ALT for the idle animation.",
        "hold A and press the arrow keybinds to play the poses.",
        "Hold S for the miss poses, or Q for the alt poses.",
        "Hold X while pressing LEFT / RIGHT to play the dance animations.",
        "C / TAB for freezing the game.",
        "IJKL for changing the offsets by 5 (SHIFT for 10 and CONTROL for 1).",
        "Mouse wheel for changing the onion skin's alpha.",
        "hold SHIFT and press Z / SPACE to select the animation for the onion skin.",
        "Hold CONTROL and S to save your character's offsets.",
        "1 to toggle this message."
    ];

    var pressed;
    var justPressed;

    var messageToggle:Bool = true;
    var savedTxt:String;

    override function onStateChangeBegin(event) {
        super.onStateChangeBegin(event);
        cleanup();
    }

    override function onStateChangeEnd(event) {
        super.onStateChangeEnd(event);
        initDebug(); 
    }

    function initDebug(){
        shit = new FlxText(0, 0, 0, "feces", 16).setBorderStyle(FlxTextBorderStyle.OUTLINE, 0xFF000000);
        shit.alignment = "center";
        shit.cameras = [PlayState.instance.camCutscene];
        PlayState.instance.add(shit);

        piss = new FlxText(0, 0, 0, "", 16).setBorderStyle(FlxTextBorderStyle.OUTLINE, 0xFF000000);
        for (i in 0...dialogueWow.length) piss.text += "> " + dialogueWow[i] + "\n";
        piss.cameras = [PlayState.instance.camCutscene];
        piss.y = FlxG.height - piss.height;
        PlayState.instance.add(piss);

        shit.visible = piss.visible = false;

        bf = PlayState.instance.currentStage.getBoyfriend();
        dad = PlayState.instance.currentStage.getDad();
        gf = PlayState.instance.currentStage.getGirlfriend();

        characters = [];

        animSelected = 0;
        charSelected = 0;

        allowed = false;
        freeze = false;

        if (bf != null){
            bfList = bf.animation.getNameList();
            characters.push(bf);
        }

        if (dad != null){
            dadList = dad.animation.getNameList();
            characters.push(dad);
        }

        if (gf != null){
            gfList = gf.animation.getNameList();
            characters.push(gf);
        }

        onionArray = [];

        if (bf != null && onionBf == null) onionSkinUpdate(onionBf, bf, true);
        if (dad != null && onionDad == null) onionSkinUpdate(onionDad, dad, true);
        if (gf != null && onionGf == null) onionSkinUpdate(onionGf, gf, true);

        for (i in 0...characters.length) {
            onionArray[i].alpha = 0.5;
            onionArray[i].zIndex = characters[i].zIndex - 1;
        }

        PlayState.instance.currentStage.refresh();
        savedTxt = "";

        loaded = true;
    }

    function onionSkinUpdate(onionSkin:FunkinSprite, char:BaseCharacter, add:Bool){
        if (add) onionSkin = new FlxSprite(0, 0);
        onionSkin.loadGraphicFromSprite(char);
        onionSkin.frame = char.frame;
        onionSkin.flipX = char.flipX;
        onionSkin.flipY = char.flipY;
        onionSkin.scale = char.scale;
        onionSkin.angle = char.angle;
        onionSkin.updateHitbox();

        onionSkin.x = char.cornerPosition.x + char.origin.x * (char.scale.x - 1) + char.globalOffsets[0] * char.scale.x;
        onionSkin.y = char.cornerPosition.y + char.origin.y * (char.scale.y - 1) + char.globalOffsets[1] * char.scale.y;

        onionSkin.offset.x = char.animOffsets[0];
        onionSkin.offset.y = char.animOffsets[1];

        if (add) {
            PlayState.instance.currentStage.add(onionSkin);
            onionArray.push(onionSkin);
        }
    }

    function animPlay(char:BaseCharacter, anim:String){
        char.playAnimation(anim, true);
        char.holdTimer = 0;
        if (anim != "idle") animSelected = curCharList.indexOf(anim);
    }

    function selecting(){
        if ((justPressed.C || justPressed.TAB) && allowed && !PlayState.instance.isGamePaused) {
            freeze = !freeze;
            freezed(freeze);
        }

        if (!allowed || !freeze) return;

        var amount:Int = pressed.SHIFT? 10 : pressed.CONTROL? 1 : 5;

        if (!(
            (pressed.A && doesContain(curCharList, animDefs)) || 
            (pressed.S && doesContain(curCharList, animDefs, "miss")) || 
            (pressed.Q && doesContain(curCharList, animDefs, "-alt"))
            )) {
            if (justPressed.LEFT) {
                animSelected--;
                if (animSelected < 0) animSelected = curCharList.length - 1;
            }
            if (justPressed.RIGHT) {
                animSelected++;
                if (animSelected > curCharList.length - 1) animSelected = 0;
            }
            if (justPressed.UP) {
                charSelected++;
                if (charSelected > characters.length - 1) charSelected = 0;
            }
            if (justPressed.DOWN) {
                charSelected--;
                if (charSelected < 0) charSelected = characters.length - 1;
            }

            if (justPressed.Z || justPressed.SPACE) 
                animPlay(characters[charSelected], curCharList[animSelected]);
            if ((justPressed.X || justPressed.ALT) && curCharList.contains("idle")) 
                animPlay(characters[charSelected], "idle");

            if (justPressed.J || justPressed.L || justPressed.I || justPressed.K) 
                animPlay(characters[charSelected], curCharList[animSelected], true);

            if (justPressed.J) characters[charSelected].animOffsets[0] += amount;
            if (justPressed.L) characters[charSelected].animOffsets[0] -= amount;
            if (justPressed.I) characters[charSelected].animOffsets[1] += amount;
            if (justPressed.K) characters[charSelected].animOffsets[1] -= amount;
        }

        if ((pressed.X || pressed.ALT) && justPressed.LEFT && curCharList.contains("danceLeft")) 
            animPlay(characters[charSelected], "danceLeft");
        if ((pressed.X || pressed.ALT) && justPressed.RIGHT && curCharList.contains("danceRight")) 
            animPlay(characters[charSelected], "danceRight");

        for (i in 0...onionArray.length) {
            if (FlxG.mouse.wheel != 0 && !(onionArray[i].alpha < 0) && !(onionArray[i].alpha > 1)) onionArray[i].alpha += 0.05 * FlxG.mouse.wheel;
        }

        if (pressed.SHIFT && ((justPressed.Z || justPressed.SPACE) || (justPressed.X || justPressed.ALT))) 
            onionSkinUpdate(onionArray[charSelected],characters[charSelected],false);

        if (justPressed.ONE) messageToggle = !messageToggle;
        piss.alpha = messageToggle? 1 : 0;

        if (pressed.CONTROL && justPressed.S) saveFile(characters[charSelected]);
    }

    function buildTxtFile(char:BaseCharacter):String {
        var output:String = "";
        for (i in char.animationOffsets.keys()) output += i + " (" + char.animationOffsets.get(i)[0] + ", " + char.animationOffsets.get(i)[1] + ")\n";
        output += "\nNow input these new values in your character's json!";
        return output;
    }

    function saveFile(char:BaseCharacter){
        var string = buildTxtFile(char);
        var path;

        for (i in PolymodHandler.getAllMods())
            if (i.title == "Animation Debug") path = "mods/" + i.id + "/Output";

        if (string != null && string.length > 0)
        {
            FileUtil.createDirIfNotExists(path);
            path += "/" + char.characterId + "Offsets.txt";
            if (FileUtil.pathExists(path)) FileUtil.deleteFile(path);
            FileUtil.writeStringToPath(path, string);
            savedTxt = "SAVED";

            var savedSound = FunkinSound.load(Paths.sound("fav"), 1);
            savedSound.play();
            savedSound.onComplete = function() {savedTxt = "";};
        }
    }

    function doesContain(one:Array<BaseCharacter>, two:Array<String>, ?string:String = "") {
        for (i in 0...two.length) {
            if (one.contains(two[i] + (string != null? string : ""))) return true;
            else return false;
        }
    }

    override function onNoteGhostMiss(event) {
        super.onNoteGhostMiss(event);
        if (!allowed || !freeze) return;

        event.cancel();
        event.stopPropagation();

        if (pressed.A && doesContain(curCharList, animDefs)) 
            animPlay(characters[charSelected], animDefs[event.dir]);

        if (pressed.S && doesContain(curCharList, animDefs, "miss") && !pressed.CONTROL) 
            animPlay(characters[charSelected], animDefs[event.dir] + "miss");

        if (pressed.Q && doesContain(curCharList, animDefs, "-alt")) 
            animPlay(characters[charSelected], animDefs[event.dir] + "-alt");
    }

    override function onUpdate(event){
        super.onUpdate(event);
        if (!loaded) return;

        pressed = FlxG.keys.pressed;
        justPressed = FlxG.keys.justPressed;
        
        switch charSelected{
            case 0: if (bf != null) curCharList = bfList;
            case 1: if (dad != null) curCharList = dadList;
            case 2: if (gf != null) curCharList = gfList;
        }

        if (animSelected > (curCharList.length - 1)) animSelected = (curCharList.length - 1);
        if (animSelected < 0) animSelected = 0;

        var animArrays:String = curCharList[animSelected] + " - " + animSelected + " / " + (curCharList.length - 1);

        var animoffsets:String = "X: " + characters[charSelected].animationOffsets.get(curCharList[animSelected])[0] 
        + " - Y: " + characters[charSelected].animationOffsets.get(curCharList[animSelected])[1];

        shit.text = "Target: " + characters[charSelected].characterName + " | " + animoffsets + " | " + animArrays + "\n" + savedTxt;
        shit.screenCenter(0x01);

        shit.visible = piss.visible = freeze;
        PlayState.instance.camHUD.visible = !freeze;
        for (i in 0...onionArray.length) onionArray[i].visible = freeze;

        PlayState.instance.playerStrumline.strumlineNotes.cameras = [freeze? PlayState.instance.camCutscene: PlayState.instance.camHUD];

        if ((freeze && (pressed.A && doesContain(curCharList, animDefs))|| (pressed.S && doesContain(curCharList, animDefs, "miss") && !pressed.CONTROL) || 
            (pressed.Q && doesContain(curCharList, animDefs, "-alt"))) || !freeze) PlayState.instance.playerStrumline.visible = true;
        else if (freeze) PlayState.instance.playerStrumline.visible = false;

        selecting();

        if (freeze) {
        PlayState.instance.resetCamera(false, false, false);
        PlayState.instance.cancelCameraFollowTween();
        PlayState.instance.cameraFollowPoint.setPosition(characters[charSelected].cameraFocusPoint.x, characters[charSelected].cameraFocusPoint.y);
        }
    }

    function freezed(bool:Bool){
        if (FlxG.sound.music == null) return;
        switch (bool){
            case true:
			if (FlxG.sound.music.playing) {
				FlxG.sound.music.pause();
				PlayState.instance.musicPausedBySubState = true;
			}
			if (PlayState.instance.vocals != null) PlayState.instance.vocals.pause();
            case false:
			FlxG.sound.music.resume();
            PlayState.instance.vocals.resume();
			PlayState.instance.musicPausedBySubState = false;
        }
    }

    override function onSongLoaded(){
        super.onSongLoaded();
        allowed = false;
    }

    override function onSongStart(){
        super.onSongStart();
        allowed = true;
    }

    override function onCountdownEnd(){
        super.onCountdownEnd();
        allowed = true;
    }

    override function onSongEnd(){
        super.onSongEnd();
        allowed = false;
    }

    override function onPause(event){
        super.onPause(event);
        if (freeze) event.cancel();
    }

    function cleanup() {
        if (shit != null) {shit.destroy(); shit = null;}
        if (piss != null) {piss.destroy(); piss = null;}

        for (i in 0...onionArray.length) {
            if (onionArray[i] != null) {onionArray[i].destroy(); onionArray[i] = null;}
        }

        loaded = false;
    }

}